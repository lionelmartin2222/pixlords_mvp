<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixlords: El Primer Juego de Propiedad de Píxeles en Blockchain</title>
    <style>
        /* ========================= CSS: VERSION 8.1 (AJUSTES DE ESCALADO Y VISUALIZACIÓN) ========================= */

        /* Fuente: Estilo Pixel Art */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a; 
            color: #FDFD96; 
            text-align: center;
            margin: 0;
            padding: 30px 10px;
            font-size: 14px; 
            line-height: 1.5; 
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            margin-bottom: 50px; 
            width: 100%;
            max-width: 1300px;
        }

        h1 {
            font-size: 48px; /* Título más grande */
            color: #39FF14; /* Verde Neón */
            text-shadow: 0 0 5px #00FF00, 0 0 10px #00FF00;
            margin-bottom: 5px; 
        }
        header p {
            font-size: 16px; 
            color: #00FFCC; /* Cyan para el subtítulo */
            margin-top: 5px;
            margin-bottom: 20px;
        }

        #wallet-info {
            font-size: 14px;
            color: #D4D4D4;
            margin-bottom: 25px;
        }

        /* Contenedor principal que define el espacio visible del mapa */
        #map-interaction-wrapper {
            width: 1300px;
            height: 520px;
            max-width: 98vw;
            overflow: hidden;
            margin: 40px auto 0;
            cursor: grab;
            position: relative;
            border: 8px solid #D4D4D4; 
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.5); 
        }

        /* --- MAPA REAL: Ahora ocupa todo el espacio del wrapper --- */
        #pixel-map-container {
            /* IMPORTANTE: El mapa debe ocupar el 100% del wrapper para verse grande al inicio */
            width: 100%; 
            height: 100%; 
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated; 
            transform-origin: 0 0; 
            transition: transform 0.1s ease-out;
            
            /* Usamos Grid para que los píxeles se ajusten al contenedor 1300x520px */
            display: grid;
            grid-template-columns: repeat(500, 1fr); /* 500 columnas de 1 fracción cada una */
            grid-template-rows: repeat(200, 1fr); /* 200 filas de 1 fracción cada una */
            touch-action: none; 
            
        }

        .pixel {
            /* El tamaño del pixel se ajusta automáticamente por el Grid (1fr x 1fr) */
            width: 100%; 
            height: 100%;
            display: block;
        }

        .pixel.selected {
            outline: 1px solid #FF00FF; /* Borde de selección neón */
            outline-offset: -1px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* --- ESTILOS DE BOTONES --- */
        .action-btn {
            background-color: #39FF14;
            color: #1a1a1a;
            border: 2px solid #39FF14;
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            font-weight: bold;
            margin: 5px;
            transition: all 0.2s;
            box-shadow: 0 0 5px #39FF14;
        }
        .action-btn:hover:not(:disabled) {
            background-color: #5eff44;
            box-shadow: 0 0 10px #5eff44;
        }
        .action-btn:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* --- BARRA DE CESTA --- */
        #cart-bar {
            background-color: #0d0d0d;
            padding: 15px 20px;
            margin: 20px auto;
            max-width: 1260px;
            border: 2px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        /* --- ESTILO DEL MODAL --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex; 
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #1a1a1a;
            border: 4px solid #39FF14;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.5);
            padding: 30px; 
            text-align: left;
        }

        #modal-message {
            color: yellow;
            margin-top: 10px;
        }

    </style>
</head>
<body>

    <header>
        <h1>PIXLORDS</h1> 
        <p>¡Sé el Señor de los Píxeles!</p>
        <div id="wallet-info">
            <button id="connect-wallet" class="action-btn">Conectar Billetera (MetaMask)</button>
            <p>Estado: <span id="status-message">DESCONECTADO</span></p>
        </div>
    </header>
    
    <main>
        <!-- BARRA DE CESTA -->
        <div id="cart-bar">
            <span id="cart-summary">Cesta: 0 píxeles seleccionados | Total: 0.00 USDC</span>
            <div>
                <button id="pay-batch-btn" class="action-btn" disabled>Pagar Lote</button>
                <button id="clear-cart-btn" class="action-btn">Limpiar Cesta</button>
            </div>
        </div>
        
        <!-- CONTENEDOR DE INTERACCIÓN (Para zoom y drag) -->
        <div id="map-interaction-wrapper">
            <!-- EL MAPA EN SÍ -->
            <div id="pixel-map-container">
            </div>
        </div>
    </main>

    <!-- MODAL DE INFORMACIÓN Y ACCIONES -->
    <div id="info-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>Información del Píxel <span id="modal-coords"></span></h2>
            <p><strong>Precio:</strong> <span id="modal-price"></span></p>
            <p><strong>Propietario:</strong> <span id="modal-owner"></span></p>
            <p><strong>Color Actual:</strong> <span id="modal-color-display"></span></p>
            
            <div id="buy-controls">
                <button id="buy-pixel-btn" class="action-btn">Comprar</button>
            </div>

            <div id="owner-controls" style="display: none;">
                <p style="color: #39FF14;">Control del Propietario:</p>
                <label for="new-color">Nuevo Color:</label>
                <input type="color" id="new-color" value="#008000">
                <button id="set-color-btn" class="action-btn">Cambiar Color</button>
                
                <hr style="border-top: 1px dashed #555; margin: 10px 0;">

                <label for="new-price">Nuevo Precio (USDC):</label>
                <input type="number" id="new-price" min="1.01" value="1.50" step="0.01">
                <button id="sell-pixel-btn" class="action-btn">Poner en Venta</button>
            </div>
            
            <button id="close-modal-btn" class="action-btn" onclick="hideModal('info-modal')">Cerrar</button>
            <p id="modal-message" style="color: yellow;"></p>
        </div>
    </div>

    <!-- CRÍTICO: Librería de conexión Web3 (Ethers.js) -->
    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js" type="application/javascript"></script> 
    
    <script>
        // ====================================================================
        // PIXLORDS - MVP - Lógica principal del juego (Frontend)
        // ====================================================================

        // --- CONFIGURACIÓN DEL MAPA ---
        const WIDTH = 500; 
        const HEIGHT = 200; 
        const TOTAL_PIXELS = WIDTH * HEIGHT;
        const INITIAL_PRICE_USDC = 1.00; 
        
        // --- ESTADO GLOBAL Y OBJETOS ---
        let selectedPixels = new Set(); 
        let mapData = []; 
        let currentAccount = null; 
        let currentPixel = { x: null, y: null }; 
        let pixelContract; 

        // --- VARIABLES DE ZOOM/ARRRASTRE ---
        let WRAPPER;
        let MAP_ELEMENT;
        let scale = 1.0;
        let position = { x: 0, y: 0 };
        let isDragging = false;
        let startDrag = { x: 0, y: 0 };
        let currentDrag = { x: 0, y: 0 };
        
        // --- VARIABLES TOUCH PARA PINCH-TO-ZOOM ---
        let initialDistance = 0;
        let lastScale = 1.0;
        let touchStartTimer = null; // CRÍTICO: Temporizador para detectar toque largo


        // --- PLACEHOLDERS DE BLOCKCHAIN (NECESARIOS PARA MUHAMMAD) ---
        const CONTRACT_ADDRESS = "DIRECCION_DE_CONTRATO_AQUI"; 
        const PIXEL_CONTRACT_ABI = []; 
        // USDC Nativo (Confirmado: 0x3c499c542ceF5E3811e1192ce70d8cc03d5C3359)
        const USDC_ADDRESS = "0x3c499c542ceF5E3811e1192ce70d8cc03d5C3359"; 

        // --- COLORES ---
        const LAND_COLOR = '#008000'; // Verde
        const SEA_COLOR = '#0000FF'; // Azul

        // --- FUNCIÓN DE COORDENADAS AMIGABLES ---
        const COORD_MAP_TO_UI = (x, y) => {
            let colStr = '';
            let tempX = x;
            while (tempX >= 0) {
                colStr = String.fromCharCode(tempX % 26 + 'A'.charCodeAt(0)) + colStr;
                tempX = Math.floor(tempX / 26) - 1;
            }
            const rowStr = y + 1; 
            return `${colStr}-${rowStr}`;
        };

        // =========================================================
        // PARTE I: MAPA GENERATIVO (SOLUCIÓN ESTABLE)
        // =========================================================
        
        // Esta función genera un mapa irregular con una masa continental central.
        function getInitialMapColor(x, y) {
            const centerX = WIDTH / 2; 
            const centerY = HEIGHT / 2; 
            
            // Coeficientes que definen la forma general (más ancha que alta)
            const factorX = 0.5; 
            const factorY = 0.8;
            
            // Distancia elíptica desde el centro (para una forma más orgánica)
            const dist = Math.sqrt(
                Math.pow((x - centerX) / factorX, 2) + 
                Math.pow((y - centerY) / factorY, 2)
            );

            // Ruido: Añade irregularidad a los bordes (como costas)
            const noise = Math.sin(x * 0.05) * 10 + Math.cos(y * 0.08) * 10;
            
            // El radio base del continente, ajustado por el ruido
            const baseRadius = 400;

            // Simulación de un lago interior 
            const isLake = (x > 180 && x < 320 && y > 80 && y < 120);
            const lakeDist = Math.sqrt(Math.pow(x - 250, 2) + Math.pow(y - 100, 2));

            let color = SEA_COLOR;
            
            if (dist < (baseRadius + noise)) {
                color = LAND_COLOR;
                
                // Si es tierra y cae dentro del área del lago, es agua
                if (isLake && lakeDist < 60) {
                    color = SEA_COLOR;
                }
            }
            
            // Simulación de pequeñas islas aleatorias
            if (Math.random() < 0.001) { 
                if (color === SEA_COLOR) {
                    color = LAND_COLOR;
                }
            }
            
            return color; 
        }

        // Inicializa el estado del mapa (Hard Reset)
        function initializeMapData() {
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const index = y * WIDTH + x;
                    
                    const color = getInitialMapColor(x, y);

                    // Estado inicial para el Hard Reset de lanzamiento (Todos Libres)
                    const isOwned = false; 
                    const owner = 'Libre'; 
                    const price = INITIAL_PRICE_USDC; 

                    mapData[index] = {
                        x,
                        y,
                        color: color,
                        owner: owner,
                        price: price,
                        isOwned: isOwned
                    };
                }
            }
        }

        // Dibuja los píxeles en el contenedor HTML
        function renderMap() {
            MAP_ELEMENT.innerHTML = ''; 

            mapData.forEach(pixel => {
                const pixelElement = document.createElement('div');
                pixelElement.className = 'pixel';
                pixelElement.style.backgroundColor = pixel.color;
                
                pixelElement.dataset.x = pixel.x;
                pixelElement.dataset.y = pixel.y;

                // El clic izquierdo (tap corto) abre el modal
                pixelElement.addEventListener('click', handlePixelClick);
                // El clic derecho (o toque largo) selecciona el pixel
                pixelElement.addEventListener('contextmenu', handlePixelRightClick); 

                MAP_ELEMENT.appendChild(pixelElement);
            });
        }

        // =========================================================
        // PARTE II: LÓGICA DE INTERACCIÓN (ZOOM Y ARRASTRE - Desktop & Mobile)
        // =========================================================

        function applyTransform() {
            MAP_ELEMENT.style.transform = `translate(${position.x}px, ${position.y}px) scale(${scale})`;
        }

        function handleZoom(event) {
            event.preventDefault();
            const delta = event.deltaY > 0 ? -0.1 : 0.1;
            // Aumento del zoom máximo a 10x
            const newScale = Math.min(Math.max(1.0, scale + delta), 10.0); 

            const rect = MAP_ELEMENT.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const oldScale = scale;
            scale = newScale;

            const ratio = oldScale / newScale;

            position.x = mouseX - (mouseX - position.x) * ratio;
            position.y = mouseY - (mouseY - position.y) * ratio;

            const maxTranslateX = (scale - 1) * WRAPPER.clientWidth;
            const maxTranslateY = (scale - 1) * WRAPPER.clientHeight;


            position.x = Math.max(Math.min(position.x, 0), -maxTranslateX);
            position.y = Math.max(Math.min(position.y, 0), -maxTranslateY);

            applyTransform();
        }

        // --- Lógica de Arrastre (Desktop) ---
        function handleMouseDown(event) {
            if (event.button !== 0 || scale === 1.0) return;
            isDragging = true;
            WRAPPER.style.cursor = 'grabbing';
            startDrag = { x: event.clientX - position.x, y: event.clientY - position.y };
            event.preventDefault(); 
        }

        function handleMouseMove(event) {
            if (!isDragging) return;
            
            const dx = event.clientX - startDrag.x;
            const dy = event.clientY - startDrag.y;
            
            const maxTranslateX = (scale - 1) * WRAPPER.clientWidth;
            const maxTranslateY = (scale - 1) * WRAPPER.clientHeight;

            position.x = Math.max(Math.min(dx, 0), -maxTranslateX);
            position.y = Math.max(Math.min(dy, 0), -maxTranslateY);

            applyTransform();
        }

        function handleMouseUp() {
            isDragging = false;
            WRAPPER.style.cursor = 'grab';
        }

        // --- Lógica Touch (Mobile - Arrastre y Zoom y Selección) ---
        function getDistance(touches) {
            if (touches.length < 2) return 0;
            return Math.sqrt(
                Math.pow(touches[0].clientX - touches[1].clientX, 2) +
                Math.pow(touches[0].clientY - touches[1].clientY, 2)
            );
        }

        function handleTouchStart(event) {
            // Limpiar cualquier temporizador pendiente
            if (touchStartTimer) {
                clearTimeout(touchStartTimer);
            }

            if (event.touches.length === 1) {
                // Posible toque simple (abre modal) o toque largo (selección)
                const touch = event.touches[0];
                currentDrag = { x: touch.clientX, y: touch.clientY }; // Guarda la posición inicial
                
                // Establecer un temporizador para simular el click derecho (toque largo)
                touchStartTimer = setTimeout(() => {
                    // Si el dedo se mantiene quieto, simular un click derecho/selección
                    handlePixelRightClick({ preventDefault: () => {}, target: document.elementFromPoint(touch.clientX, touch.clientY) });
                    isDragging = false; // Bloquear el arrastre después de la selección
                    touchStartTimer = null;
                }, 500); // 500ms para toque largo

                // Preparar para arrastre (si no es toque largo)
                if (scale > 1.0) {
                    isDragging = true;
                    startDrag = { x: event.touches[0].clientX - position.x, y: event.touches[0].clientY - position.y };
                }

            } else if (event.touches.length === 2) {
                // Inicio de Pinch-to-Zoom
                initialDistance = getDistance(event.touches);
                lastScale = scale;
                isDragging = false; // Desactivar arrastre simple
            }
            // Importante: No prevenir por defecto aquí si se quiere el toque largo
        }

        function handleTouchMove(event) {
            // Si hay un movimiento significativo, cancelar el toque largo
            if (touchStartTimer) {
                const touch = event.touches[0];
                const deltaX = Math.abs(touch.clientX - currentDrag.x);
                const deltaY = Math.abs(touch.clientY - currentDrag.y);
                
                // Si el movimiento es mayor a 10 píxeles, se asume arrastre y se cancela el toque largo
                if (deltaX > 10 || deltaY > 10) {
                    clearTimeout(touchStartTimer);
                    touchStartTimer = null;
                    isDragging = scale > 1.0; // Re-habilitar arrastre si hay zoom
                }
            }

            if (event.touches.length === 1 && isDragging) {
                // Arrastre simple (un dedo)
                const touch = event.touches[0];
                const dx = touch.clientX - startDrag.x;
                const dy = touch.clientY - startDrag.y;
                
                const maxTranslateX = (scale - 1) * WRAPPER.clientWidth;
                const maxTranslateY = (scale - 1) * WRAPPER.clientHeight;

                position.x = Math.max(Math.min(dx, 0), -maxTranslateX);
                position.y = Math.max(Math.min(dy, 0), -maxTranslateY);
                
                applyTransform();
                event.preventDefault(); // Prevenir el scroll por defecto si estamos arrastrando
            } else if (event.touches.length === 2 && initialDistance > 0) {
                // Pinch-to-Zoom (dos dedos)
                const newDistance = getDistance(event.touches);
                const zoomFactor = newDistance / initialDistance;
                let newScale = lastScale * zoomFactor;

                // Limitar el zoom (Aumentado a 10.0)
                newScale = Math.min(Math.max(1.0, newScale), 10.0);

                const centerClientX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                const centerClientY = (event.touches[0].clientY + event.touches[1].clientY) / 2;

                const rect = MAP_ELEMENT.getBoundingClientRect();
                const mouseX = centerClientX - position.x; // Usamos position.x/y para calcular el punto en el mapa
                const mouseY = centerClientY - position.y;

                const ratio = scale / newScale;

                // Recalcular posición
                position.x = centerClientX - (centerClientX - position.x) * ratio;
                position.y = centerClientY - (centerClientY - position.y) * ratio;


                scale = newScale;
                
                const maxTranslateX = (scale - 1) * WRAPPER.clientWidth;
                const maxTranslateY = (scale - 1) * WRAPPER.clientHeight;
                
                position.x = Math.max(Math.min(position.x, 0), -maxTranslateX);
                position.y = Math.max(Math.min(position.y, 0), -maxTranslateY);


                applyTransform();
                event.preventDefault();
            }
        }

        function handleTouchEnd(event) {
            // Si el temporizador de toque largo aún está activo al levantar el dedo, es un TAP corto -> abrir modal
            if (touchStartTimer) {
                clearTimeout(touchStartTimer);
                // Determinar si el toque finalizó en el elemento que queremos
                if (event.changedTouches.length === 1) {
                    const touch = event.changedTouches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    // Solo si el elemento es un píxel, lo tratamos como un clic
                    if (element && element.classList.contains('pixel')) {
                        handlePixelClick({ target: element }); // Simular clic izquierdo para abrir modal
                    }
                }
            }

            isDragging = false;
            initialDistance = 0;
            lastScale = scale; 
        }
        
        // =========================================================
        // PARTE III: LÓGICA DE NEGOCIO (SELECCIÓN Y MODAL)
        // =========================================================

        function handlePixelClick(event) {
            const pixelElement = event.target;
            const x = parseInt(pixelElement.dataset.x);
            const y = parseInt(pixelElement.dataset.y);
            const index = y * WIDTH + x;
            const pixel = mapData[index];

            showModal(pixel, pixelElement);
        }

        function handlePixelRightClick(event) {
            const targetElement = event.target;
            
            // Para escritorio, prevenimos el menú contextual
            if (event.preventDefault) {
                event.preventDefault(); 
            }
            
            const x = parseInt(targetElement.dataset.x);
            const y = parseInt(targetElement.dataset.y);
            const id = `${x}-${y}`; 
            const pixel = mapData[y * WIDTH + x];

            if (!pixel.isOwned) {
                if (selectedPixels.has(id)) {
                    selectedPixels.delete(id);
                    targetElement.classList.remove('selected');
                } else {
                    selectedPixels.add(id);
                    targetElement.classList.add('selected');
                }
                updateCartSummary();
            } else {
                const modal = document.getElementById('info-modal');
                const message = modal.querySelector('#modal-message');
                message.textContent = "Este píxel ya está comprado. Haz clic izquierdo para ver detalles.";
                setTimeout(() => { message.textContent = ""; }, 3000); 
            }
        }

        function updateCartSummary() {
            const count = selectedPixels.size;
            const totalCost = count * INITIAL_PRICE_USDC; 
            
            document.getElementById('cart-summary').textContent = 
                `Cesta: ${count} píxeles seleccionados | Total: ${totalCost.toFixed(2)} USDC`;
                
            document.getElementById('pay-batch-btn').disabled = count === 0;
        }

        function clearCart() {
            selectedPixels.forEach(id => {
                const [x, y] = id.split('-').map(Number);
                const element = MAP_ELEMENT.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
                if (element) {
                    element.classList.remove('selected');
                }
            });
            selectedPixels.clear();
            updateCartSummary();
        }

        function showModal(pixel, element) {
            const modal = document.getElementById('info-modal');
            
            document.getElementById('modal-coords').textContent = COORD_MAP_TO_UI(pixel.x, pixel.y);
            document.getElementById('modal-price').textContent = `${pixel.price.toFixed(2)} USDC`;
            document.getElementById('modal-owner').textContent = pixel.owner;
            
            const colorDisplay = document.getElementById('modal-color-display');
            colorDisplay.style.width = '20px'; 
            colorDisplay.style.height = '20px';
            colorDisplay.style.display = 'inline-block';
            colorDisplay.style.verticalAlign = 'middle';
            colorDisplay.style.backgroundColor = pixel.color;
            colorDisplay.style.border = '1px solid #FDFD96';

            const isUserOwner = (currentAccount && pixel.owner === currentAccount); 

            document.getElementById('owner-controls').style.display = isUserOwner ? 'block' : 'none'; 
            const buyBtn = document.getElementById('buy-pixel-btn');

            if (!pixel.isOwned) {
                buyBtn.textContent = 'AÑADIR A CESTA (Lote)';
                buyBtn.onclick = () => {
                    handlePixelRightClick({ preventDefault: () => {}, target: element });
                    hideModal('info-modal');
                };
            } else {
                buyBtn.textContent = `COMPRAR (Reventa) por ${pixel.price.toFixed(2)} USDC`;
                buyBtn.onclick = () => {
                    alertPlaceholder('Compra Individual/Reventa iniciada. Esperando conexión blockchain.');
                    hideModal('info-modal');
                };
            }

            modal.style.display = 'flex';
        }

        function hideModal(id) {
            document.getElementById(id).style.display = 'none';
            document.getElementById('modal-message').textContent = "";
        }
        
        function alertPlaceholder(message) {
            console.log("ALERTA PLACEHOLDER: " + message);
        }

        // =========================================================
        // PARTE IV: CONEXIÓN REAL A BLOCKCHAIN (PLACEHOLDERS) Y SETUP
        // =========================================================

        async function connectWallet() {
            const statusMessage = document.getElementById('status-message');
            const connectBtn = document.getElementById('connect-wallet');
            
            if (window.ethereum) {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    currentAccount = accounts[0];
                    statusMessage.textContent = `Conectado: ${currentAccount.substring(0, 6)}...`;
                    connectBtn.textContent = 'Desconectar';
                    statusMessage.style.color = '#39FF14'; 
                    connectBtn.onclick = disconnectWallet;
                    
                    alertPlaceholder("Conexión de billetera exitosa.");

                } catch (error) {
                    console.error("Error al conectar la billetera:", error);
                    statusMessage.textContent = 'Error de Conexión';
                    statusMessage.style.color = 'red';
                }
            } else {
                alertPlaceholder("MetaMask no detectado. Por favor instálelo.");
            }
        }

        function disconnectWallet() {
            currentAccount = null;
            const statusMessage = document.getElementById('status-message');
            const connectBtn = document.getElementById('connect-wallet');
            
            statusMessage.textContent = 'DESCONECTADO';
            connectBtn.textContent = 'Conectar Billetera (MetaMask)';
            statusMessage.style.color = '#FDFD96'; 
            connectBtn.onclick = connectWallet;
            alertPlaceholder("Billetera desconectada.");
        }

        function executeBatchPurchase() {
            if (selectedPixels.size > 0) {
                alertPlaceholder(`Compra por LOTE de ${selectedPixels.size} píxeles iniciada. Esperando transacción blockchain.`);
                clearCart();
            }
        }

        // =========================================================
        // PARTE V: INICIALIZACIÓN DEL DOCUMENTO
        // =========================================================

        document.addEventListener('DOMContentLoaded', () => {
            WRAPPER = document.getElementById('map-interaction-wrapper');
            MAP_ELEMENT = document.getElementById('pixel-map-container');
            
            // 1. Inicializa y dibuja el mapa (USA EL MAPA GENERATIVO ESTABLE)
            initializeMapData();
            renderMap();
            
            // 2. Configuración de eventos de Zoom y Arrastre (Desktop)
            WRAPPER.addEventListener('wheel', handleZoom);
            WRAPPER.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // 3. Configuración de eventos Touch (Mobile)
            WRAPPER.addEventListener('touchstart', handleTouchStart);
            WRAPPER.addEventListener('touchmove', handleTouchMove);
            WRAPPER.addEventListener('touchend', handleTouchEnd);
            
            // 4. Configuración de eventos de Negocio y Billetera
            document.getElementById('connect-wallet').addEventListener('click', connectWallet);
            document.getElementById('pay-batch-btn').addEventListener('click', executeBatchPurchase);
            document.getElementById('clear-cart-btn').addEventListener('click', clearCart);
            document.getElementById('close-modal-btn').addEventListener('click', () => hideModal('info-modal'));
            
            // 5. Placeholders de controles de propietario
            document.getElementById('set-color-btn').addEventListener('click', () => {
                alertPlaceholder("Simulación: Cambiando color. Esperando Smart Contract.");
                hideModal('info-modal');
            });
            
            document.getElementById('sell-pixel-btn').addEventListener('click', () => {
                alertPlaceholder("Simulación: Poniendo píxel en venta. Esperando Smart Contract.");
                hideModal('info-modal');
            });
        });
    </script>
</body>
</html>
